{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* eslint-disable */\n\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* globals PDFJS */\n\n/**\n * @typedef {Object} TextLayerBuilderOptions\n * @property {HTMLDivElement} textLayerDiv - The text layer container.\n * @property {number} pageIndex - The page index.\n * @property {PageViewport} viewport - The viewport of the text layer.\n * @property {PDFFindController} findController\n */\n\n/**\n * TextLayerBuilder provides text-selection functionality for the PDF.\n * It does this by creating overlay divs over the PDF text. These divs\n * contain text that matches the PDF text they are overlaying. This object\n * also provides a way to highlight text that is being searched for.\n * @class\n */\n\nvar TextLayerBuilder = function TextLayerBuilderClosure() {\n  function TextLayerBuilder(options) {\n    this.textLayerDiv = options.textLayerDiv;\n    this.renderingDone = false;\n    this.divContentDone = false;\n    this.pageIdx = options.pageIndex;\n    this.pageNumber = this.pageIdx + 1;\n    this.matches = [];\n    this.viewport = options.viewport;\n    this.textDivs = [];\n    this.findController = options.findController || null;\n    this.textLayerRenderTask = null;\n\n    this._bindMouse();\n  }\n\n  TextLayerBuilder.prototype = {\n    _finishRendering: function TextLayerBuilder_finishRendering() {\n      this.renderingDone = true;\n      var endOfContent = document.createElement('div');\n      endOfContent.className = 'endOfContent';\n      this.textLayerDiv.appendChild(endOfContent);\n      var event = document.createEvent('CustomEvent');\n      event.initCustomEvent('textlayerrendered', true, true, {\n        pageNumber: this.pageNumber\n      });\n      this.textLayerDiv.dispatchEvent(event);\n    },\n\n    /**\n     * Renders the text layer.\n     * @param {number} timeout (optional) if specified, the rendering waits\n     *   for specified amount of ms.\n     */\n    render: function TextLayerBuilder_render(timeout) {\n      var _this = this;\n\n      if (!this.divContentDone || this.renderingDone) {\n        return;\n      }\n\n      if (this.textLayerRenderTask) {\n        this.textLayerRenderTask.cancel();\n        this.textLayerRenderTask = null;\n      }\n\n      this.textDivs = [];\n      var textLayerFrag = document.createDocumentFragment();\n      this.textLayerRenderTask = PDFJS.renderTextLayer({\n        textContent: this.textContent,\n        container: textLayerFrag,\n        viewport: this.viewport,\n        textDivs: this.textDivs,\n        timeout: timeout\n      });\n      this.textLayerRenderTask.promise.then(function () {\n        _this.textLayerDiv.appendChild(textLayerFrag);\n\n        _this._finishRendering();\n\n        _this.updateMatches();\n      }, function (reason) {// canceled or failed to render text layer -- skipping errors\n      });\n    },\n    setTextContent: function TextLayerBuilder_setTextContent(textContent) {\n      if (this.textLayerRenderTask) {\n        this.textLayerRenderTask.cancel();\n        this.textLayerRenderTask = null;\n      }\n\n      this.textContent = textContent;\n      this.divContentDone = true;\n    },\n    convertMatches: function TextLayerBuilder_convertMatches(matches) {\n      var i = 0;\n      var iIndex = 0;\n      var bidiTexts = this.textContent.items;\n      var end = bidiTexts.length - 1;\n      var queryLen = this.findController === null ? 0 : this.findController.state.query.length;\n      var ret = [];\n\n      for (var m = 0, len = matches.length; m < len; m++) {\n        // Calculate the start position.\n        var matchIdx = matches[m]; // Loop over the divIdxs.\n\n        while (i !== end && matchIdx >= iIndex + bidiTexts[i].str.length) {\n          iIndex += bidiTexts[i].str.length;\n          i++;\n        }\n\n        if (i === bidiTexts.length) {\n          console.error('Could not find a matching mapping');\n        }\n\n        var match = {\n          begin: {\n            divIdx: i,\n            offset: matchIdx - iIndex\n          }\n        }; // Calculate the end position.\n\n        matchIdx += queryLen; // Somewhat the same array as above, but use > instead of >= to get\n        // the end position right.\n\n        while (i !== end && matchIdx > iIndex + bidiTexts[i].str.length) {\n          iIndex += bidiTexts[i].str.length;\n          i++;\n        }\n\n        match.end = {\n          divIdx: i,\n          offset: matchIdx - iIndex\n        };\n        ret.push(match);\n      }\n\n      return ret;\n    },\n    renderMatches: function TextLayerBuilder_renderMatches(matches) {\n      // Early exit if there is nothing to render.\n      if (matches.length === 0) {\n        return;\n      }\n\n      var bidiTexts = this.textContent.items;\n      var textDivs = this.textDivs;\n      var prevEnd = null;\n      var pageIdx = this.pageIdx;\n      var isSelectedPage = this.findController === null ? false : pageIdx === this.findController.selected.pageIdx;\n      var selectedMatchIdx = this.findController === null ? -1 : this.findController.selected.matchIdx;\n      var highlightAll = this.findController === null ? false : this.findController.state.highlightAll;\n      var infinity = {\n        divIdx: -1,\n        offset: undefined\n      };\n\n      function beginText(begin, className) {\n        var divIdx = begin.divIdx;\n        textDivs[divIdx].textContent = '';\n        appendTextToDiv(divIdx, 0, begin.offset, className);\n      }\n\n      function appendTextToDiv(divIdx, fromOffset, toOffset, className) {\n        var div = textDivs[divIdx];\n        var content = bidiTexts[divIdx].str.substring(fromOffset, toOffset);\n        var node = document.createTextNode(content);\n\n        if (className) {\n          var span = document.createElement('span');\n          span.className = className;\n          span.appendChild(node);\n          div.appendChild(span);\n          return;\n        }\n\n        div.appendChild(node);\n      }\n\n      var i0 = selectedMatchIdx,\n          i1 = i0 + 1;\n\n      if (highlightAll) {\n        i0 = 0;\n        i1 = matches.length;\n      } else if (!isSelectedPage) {\n        // Not highlighting all and this isn't the selected page, so do nothing.\n        return;\n      }\n\n      for (var i = i0; i < i1; i++) {\n        var match = matches[i];\n        var begin = match.begin;\n        var end = match.end;\n        var isSelected = isSelectedPage && i === selectedMatchIdx;\n        var highlightSuffix = isSelected ? ' selected' : '';\n\n        if (this.findController) {\n          this.findController.updateMatchPosition(pageIdx, i, textDivs, begin.divIdx, end.divIdx);\n        } // Match inside new div.\n\n\n        if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {\n          // If there was a previous div, then add the text at the end.\n          if (prevEnd !== null) {\n            appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n          } // Clear the divs and set the content until the starting point.\n\n\n          beginText(begin);\n        } else {\n          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);\n        }\n\n        if (begin.divIdx === end.divIdx) {\n          appendTextToDiv(begin.divIdx, begin.offset, end.offset, 'highlight' + highlightSuffix);\n        } else {\n          appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, 'highlight begin' + highlightSuffix);\n\n          for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {\n            textDivs[n0].className = 'highlight middle' + highlightSuffix;\n          }\n\n          beginText(end, 'highlight end' + highlightSuffix);\n        }\n\n        prevEnd = end;\n      }\n\n      if (prevEnd) {\n        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n      }\n    },\n    updateMatches: function TextLayerBuilder_updateMatches() {\n      // Only show matches when all rendering is done.\n      if (!this.renderingDone) {\n        return;\n      } // Clear all matches.\n\n\n      var matches = this.matches;\n      var textDivs = this.textDivs;\n      var bidiTexts = this.textContent.items;\n      var clearedUntilDivIdx = -1; // Clear all current matches.\n\n      for (var i = 0, len = matches.length; i < len; i++) {\n        var match = matches[i];\n        var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);\n\n        for (var n = begin, end = match.end.divIdx; n <= end; n++) {\n          var div = textDivs[n];\n          div.textContent = bidiTexts[n].str;\n          div.className = '';\n        }\n\n        clearedUntilDivIdx = match.end.divIdx + 1;\n      }\n\n      if (this.findController === null || !this.findController.active) {\n        return;\n      } // Convert the matches on the page controller into the match format\n      // used for the textLayer.\n\n\n      this.matches = this.convertMatches(this.findController === null ? [] : this.findController.pageMatches[this.pageIdx] || []);\n      this.renderMatches(this.matches);\n    },\n\n    /**\n     * Fixes text selection: adds additional div where mouse was clicked.\n     * This reduces flickering of the content if mouse slowly dragged down/up.\n     * @private\n     */\n    _bindMouse: function TextLayerBuilder_bindMouse() {\n      var div = this.textLayerDiv;\n      div.addEventListener('mousedown', function (e) {\n        var end = div.querySelector('.endOfContent');\n\n        if (!end) {\n          return;\n        } // #if !(MOZCENTRAL || FIREFOX)\n        // On non-Firefox browsers, the selection will feel better if the height\n        // of the endOfContent div will be adjusted to start at mouse click\n        // location -- this will avoid flickering when selections moves up.\n        // However it does not work when selection started on empty space.\n\n\n        var adjustTop = e.target !== div; // #if GENERIC\n\n        adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue('-moz-user-select') !== 'none'; // #endif\n\n        if (adjustTop) {\n          var divBounds = div.getBoundingClientRect();\n          var r = Math.max(0, (e.pageY - divBounds.top) / divBounds.height);\n          end.style.top = (r * 100).toFixed(2) + '%';\n        } // #endif\n\n\n        end.classList.add('active');\n      });\n      div.addEventListener('mouseup', function (e) {\n        var end = div.querySelector('.endOfContent');\n\n        if (!end) {\n          return;\n        } // #if !(MOZCENTRAL || FIREFOX)\n\n\n        end.style.top = ''; // #endif\n\n        end.classList.remove('active');\n      });\n    }\n  };\n  return TextLayerBuilder;\n}();\n\nexports.default = TextLayerBuilder;\n/**\n * @constructor\n * @implements IPDFTextLayerFactory\n */\n\nfunction DefaultTextLayerFactory() {}\n\nDefaultTextLayerFactory.prototype = {\n  /**\n   * @param {HTMLDivElement} textLayerDiv\n   * @param {number} pageIndex\n   * @param {PageViewport} viewport\n   * @returns {TextLayerBuilder}\n   */\n  createTextLayerBuilder: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {\n    return new TextLayerBuilder({\n      textLayerDiv: textLayerDiv,\n      pageIndex: pageIndex,\n      viewport: viewport\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}